import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { InvoiceScheduleService } from './invoice-schedule.service';
import { InvoiceService } from './invoice.service';
import { PrismaService } from '../../../database/prisma.service';
import { InvoiceScheduleModel } from 'src/database/generated/models/InvoiceSchedule';
import { PayrollStatusEnum } from 'src/database/generated/enums';
import { MailService } from 'src/modules/mail/mail.service';

@Injectable()
export class InvoiceSchedulerService {
  private readonly logger = new Logger(InvoiceSchedulerService.name);

  constructor(
    private readonly scheduleService: InvoiceScheduleService,
    private readonly invoiceService: InvoiceService,
    private readonly prisma: PrismaService,
    private readonly mailService: MailService,
  ) {}

  /**
   * Run every hour to check for invoices that need to be generated
   */
  @Cron(CronExpression.EVERY_10_SECONDS)
  async generateScheduledInvoices() {
    try {
      const now = new Date();
      const schedules =
        await this.scheduleService.getSchedulesDueForGeneration(now);

      if (schedules.length === 0) {
        this.logger.debug('No invoices scheduled for generation');
        return;
      }

      for (const schedule of schedules) {
        try {
          await this.generateInvoiceFromSchedule(schedule);
        } catch (error) {
          this.logger.error(
            `Failed to generate invoice for schedule ${schedule.id}:`,
            error,
          );
          // Continue with other schedules even if one fails
        }
      }
    } catch (error) {
      this.logger.error('Error in invoice generation scheduler:', error);
    }
  }

  /**
   * Generate invoice from a schedule
   */
  private async generateInvoiceFromSchedule(
    schedule: InvoiceScheduleModel & {
      payroll: {
        id: number;
        companyId: number;
        status: string;
        amount: string;
        payStartDate: Date;
        payEndDate: Date;
        employee: { email: string; name: string };
        company: { companyName: string };
      };
    },
  ): Promise<void> {
    return this.prisma.$transaction(async (tx) => {
      const { payroll } = schedule;

      // Check if payroll is still active
      if (payroll.status !== PayrollStatusEnum.ACTIVE) {
        this.logger.warn(
          `Skipping invoice generation for payroll ${payroll.id} - payroll is not active`,
        );
        return;
      }

      // Check if invoice already exists for this period
      const latestInvoice =
        await this.invoiceService.findLatestInvoiceForPayroll(payroll.id, tx);

      if (latestInvoice) {
        const latestDate = new Date(latestInvoice.issueDate);
        const now = new Date();
        const daysDiff = Math.floor(
          (now.getTime() - latestDate.getTime()) / (1000 * 60 * 60 * 24),
        );

        // Prevent duplicate generation within the same period
        if (daysDiff < 28) {
          this.logger.warn(
            `Skipping invoice generation - invoice already exists within 28 days for payroll ${payroll.id}`,
          );
          return;
        }
      }

      // Calculate due date based on schedule
      const issueDate = new Date();
      const dueDate = new Date(issueDate);
      dueDate.setDate(dueDate.getDate() + 30); // Default 30 days

      // Generate invoice
      const invoice = await this.invoiceService.generateInvoice(
        payroll.id,
        payroll.companyId,
        tx,
        {
          issueDate,
          dueDate,
          isAutoGenerated: true,
          autoGenerateFromPayrollId: payroll.id,
        },
      );

      // Calculate month string from payroll dates
      const month = new Date(payroll.payStartDate).toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric',
      });

      // Send email to employee
      await this.mailService.sendInvoiceNotification(
        payroll.employee.email,
        invoice.invoiceNumber,
        invoice.uuid,
        invoice.dueDate,
        payroll.company.companyName,
        payroll.employee.name,
        payroll.amount,
        month,
      );

      // Calculate next generate date
      const nextGenerateDate = this.calculateNextGenerateDate(
        schedule.frequency,
        schedule.dayOfMonth,
        schedule.dayOfWeek,
        schedule.generateDaysBefore,
      );

      // Update schedule
      await this.scheduleService.markAsGenerated(
        schedule.id,
        issueDate,
        nextGenerateDate,
        tx,
      );

      this.logger.log(
        `Generated invoice ${invoice.invoiceNumber} from schedule ${schedule.id}`,
      );
    });
  }

  /**
   * Calculate next generate date
   */
  private calculateNextGenerateDate(
    frequency: string,
    dayOfMonth?: number,
    dayOfWeek?: number,
    generateDaysBefore: number = 0,
  ): Date {
    const now = new Date();
    let nextDate = new Date();

    switch (frequency.toUpperCase()) {
      case 'SANDBOX': // fast cycle for testing
        nextDate = new Date(now.getTime() + 30 * 1000); // 30 seconds later
        break;
      case 'MONTHLY':
        if (dayOfMonth) {
          nextDate = new Date(
            now.getFullYear(),
            now.getMonth() + 1,
            dayOfMonth,
          );
        } else {
          nextDate = new Date(now.getFullYear(), now.getMonth() + 2, 1);
        }
        break;

      case 'WEEKLY':
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + 7);
        break;

      case 'BIWEEKLY':
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + 14);
        break;

      case 'QUARTERLY':
        nextDate = new Date(now.getFullYear(), now.getMonth() + 3, 1);
        break;

      default:
        nextDate = new Date(now);
        nextDate.setDate(now.getDate() + 30);
    }

    // Subtract generateDaysBefore
    if (generateDaysBefore > 0) {
      nextDate.setDate(nextDate.getDate() - generateDaysBefore);
    }

    return nextDate;
  }
}
